### Name  
Pierce Forte (phf7)

### Note  
I will mention this here so I don't have to do so repeatedly throughout the document. Since I joined the class late, I was only able to fully complete the Basic requirements and the first 4 of the Complete requirements (without proper testing, however). My main() worked on the complete data set and provided printed output regarding the different questions I completed, and I handled some errors like when a name was not present in the dataset, when a matching-rank-request was not valid (rank not present in a given year), and when a given file to take data from was not valid. Finally, my program is only able to read data from files stored locally and in the same folder, but this location (as well as the years of data available) can easily be modified within the code in the "Main" or "NameCollectorTest" class's constant variables.

### Development Roles  
Since this was a single-person assignment, I completed all of the work.

### Design Goals  
My main design goals were to build an effective data structure for storing and ranking the names, and to slowly build up to the more advanced features. For example, I started off with creating a method to find a name's popularity, then used this feature to make a method for ranking the names, then made a method to find a name's rank, then made a method to find a name's overall rank in multiple years, etc. By building up from simple methods to more complex ones, adding features became easier because most of the work (the smaller pieces of the more complex function's purpose) had already been completed. Furthermore, to eliminate dependencies between questions, I did things that I thought would be useful in the future within the NameCollector class; for example, I ranked the names here and added them to a global map.  

### High-level Design
The "Main" and "NameCollectorTest" classes both served as ways to gather input. Here, the files containing baby name data can be read based on a range of years (which are set in constant variables), and they are used to create a "NameCollector" object. This "NameCollector" class served as the processing aspect of the program. It creates the data structures that store the names and their popularities, and it offers the methods for answering each of the assignment questions. Finally, this class also provides output to the user when one of its methods is called (from an instance of the class) from the "Main" and "NameCollectorTest" classes; the information is printed to the screen, and since the methods also return the requested information, they can be tested within the "NameCollectorTest" class.

### Assumptions  
The initalizeNameCollector() and formatFileName() classes assume that the name files are given in the format "yob****.txt", where **** is the year. It is also assumed that the actual files are contained in the data/ssa_complete/ directory, and that the test files are contained in the data/test/ directory. This made it easier for me to design the program because I didn't have to account for the very real possibility that a file might be named differently or stored elsewhere; however, I did make it very easy for a user to adjust these things within the code by placing the assumed file paths and year ranges in constant variables.

It is assumed that for Basic question 4, the overall popularity of a starting letter is determined based on how many babies were given a name with this starting letter (regardless of the name), NOT the number of different names with this starting letter. For example, for the range 2000 to 2001, if the name Anne was given 500 times in 2000, and Jane and Jessica were each given 10 times in each of the aforementioned years, the starting letter "A" would be considered most popular: the total for "A" is 500, and the total for "J" is 40. This assumption made designing the program easier because I did not have to account for different interpretations (perhaps by adding a boolean parameter to the method and using an if tree to return the correct output); instead, I merely had to implement my understanding of the question.   

Further, an early decision I made was to create a single two-level hashmap (one needs to say, for example, map.get().get() to obtain the requested data) to store all of the ranks and a single three-level hashmap to store all of the names and their popularities. The reason I chose to store the data like this was because it allowed me to store *everything* all in once place, and I had a consistent way of accessing a name's rank regardless of that name's sex or year. By taking the time to correctly implement a more complex data structure, I was able to avoid any worries later on of where the data I needed was or how to access it.


### How to Add New Features  
Since I did not do Complete requirements 5-10, I will explain how to add them here.  

5) **Given a name and a range of years, what is its average rank during that time (regardless of gender)?**  
This feature would be implemented with two functions. The first (rankNamesRegardlessOfGender) would go through the already-determined ranks (which are by gender) and for each year and each gender, it would add the ranked names to a sorted list for that year. The resulting lists would be placed into a global hashmap (called rankedNamesRegardlessOfGender), which would map from year to a sorted list of the ranked names for that year. This function would likely be called within the constructor for the NameCollector class so that these ranks could be accessed easily for other features. Next, the second method, which would be specific to this question, would contain an ArrayList to store the rank of a given name from each year. There would be a for loop to repeatedly determine the rank of the name for each year using the first method described above, the rank would be added to the list, and then the function would return the average of this list.  
  
6) **Given a name and a number of years, what is its average rank for the most recent number of years (regardless of gender)?**  
Utilizing the "maxYear" global variable in the NameCollector class, which stores the most recent year, this function would call the second function described in question 5, which would accept a range of years. The end year would be the most recent year, and the start year would simply be this number minus the given number of years. Further, there would be an if statement to check whether the calculated start year is less than the first year of data available (stored in "minYear"); if this were the case, an exception would be thrown.  

7) **Given a range of years, a gender, and a rank, what name/gender pairs held that rank at the first to the last years of the range?**  
Since a method (getMatchingRankInMostRecentYear) is already in place to find a matching name/gender pair in the most recent year, I would create a function called something like getMatchingRank to find the matching pair from *any* year. The getMatchingRankInMostRecentYear function would then simply call this new method and provide the most recent year as a parameter that indicates which year the matching pair will come from. Next, to implement the feature in this question, I would simply have a method that calls the getMatchingRank method for the first and last years of the provided range, and it would return the corresponding names in an ArrayList.

8) **Given a range of years and a rank, what name(s) held that rank most often within the range (regardless of gender) and how many years did they have at that rank?**  
I would first implement a method called getRankRegardlessOfGender that returns the rank of a name for a given year regardless of gender. This would implement the same functionality as the getRankBySexYearAndName function (the duplicate code would be refactored into its own method) and return a name's rank for that year based on its index in the sorted rank ArrayList. Next, the method for this question would create a local hashmap, mapping from name to the number of years at a given rank. A for loop would loop through the given range of years and add names with the given rank to the hashmap and update its number of occurences at that rank. Finally, the max number of occurences would be determined, and the method would return a list of the names with that number of occurences.

9) **Given a range of years, what name(s) were ranked as the yearâ€™s most popular name most often (regardless of gender) and how many years did they have the top rank? Answer this question by also including their meaning (using this additional data file).**  
To first address this question, I would create a global hashmap that maps from name to meaning, and I would add each name and its meaning to the hashmap while iterating through the additional data file. This function would be called within the NameCollector constructor so that the names' meanings could be accessed for future features. Next, I would simply call the getMostFrequentTopRankedNameInRangeOfYears method used to answer Basic question 3, which returns the names with the most top ranks in the given range of years, and I would return these names mapped to their meanings.

10) **Extra credit: Given a range of years and a gender, what is the most popular name prefix? Answer this question with an alphabetized list of all names with that prefix.**   
This question seems particularly challenging. To solve it, I would create a set of all possible prefixes (in other words, all substrings from index 0 to [1, length of name) of each of the names in the entire dataset). Then, for each name, I would check if each of these prefixes is at the start of the name, and if it is, I would add the prefix to a hasmap (from prefix to number of occurences) and update its number of occurences. To check if a name is a prefix, I would first check if the prefix is shorter than or equal to the name's length, and if so, I would check whether the substring of the name from index 0 to the length of the prefix - 1 is equal to the prefix. Finally, I would iterate through the hasmap and return an arraylist of the prefixes with the the top number of occurences.

#### Other Features
Further, since I did not read from a URL or handle all errors (I have already handled invalid files), I will discuss how to do that here.

#### URL
To read from a URL, I would follow the instructions here https://docs.oracle.com/javase/tutorial/networking/urls/readingURL.html, implementing an InputStream to read through the contents of the URL, go through the given directories, and add data to a NameCollector instance.  

#### Errors
To handle a non "M" or "F" gender, I would check whether the provided gender is equal to "M" or "F", and if not, I would throw an error, not add this name to the names stored in NameCollector, and continue through the rest of the names.  

I assume that "names that do not match the exact case of those in the various data files" would mean names with unusual uppercase or lowercase letters. Since my code does not rely on a name's case, this would not cause any errors and would not require any handling. That said, I feel like I may have misenterpreted this requirement, but I hope not.  

For invalid year ranges, I would simply have a method that determines whether a year is valid. Within each method that looks into the name data structures for a given year, I would call this method and throw an error if the given year was invalid. 
